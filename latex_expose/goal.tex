
\section{Goal}

The proposed thesis will give an overview over algorithms and methods used to reconstruct explicit triangle meshes from different kinds of implicit geometry models. In reference to the first problem statement, a categorization if the presented algorithms will be shown to group common concepts and compare the algorithms based on their approaches, area of application, supported data structures and restrictions.

After this overview, the thesis will discuss the prototypic implementation of selected algorithms, as well as combinations and variations of them. These implementations will be based on the data model of Enlight. Nevertheless, the author will try his best to keep the implementations as generic as possible and point out how certain implementations may be adapted for different kind of implicit data structures where possible. All algorithms will be compared using the aspects given in the second problem statement. Although time constrained surface extracting will not be focused, the thesis will also try to estimate each algorithms potential to be used in real-time scenarios, as this is an important sector in collision detection and avoidance during machining. Furthermore, as modern hardware architectures become increasingly parallel and heterogeneous, the thesis may also provide hints and estimates about the suitability to parallelize the chosen algorithms.

Furthermore, a suite of representative test models will be created used to benchmark the prototyped approaches. The primary goal is to point out the strengths and limitations of the implemented prototypes and to compare them again on their success on various difficulties of the provided test scenes (e.g. adaptivity, feature detection, errors). Finally, the thesis will be able to list estimates and advices about which algorithms and strategies work best for which kind of input.

This thesis does not provide a detailed introduction into virtual machining, ray tracing nor computer graphics. Furthermore, all implementations of algorithms will be prototypes and may not be suitable for every kind of input. The author will try his best to write stable implementations but cannot guarantee that these cover every case occurring in various input models. Additionally, the presented algorithm will not be tuned for performance. Optimization is a tedious task and requires a great deal of time which can be spent more effectively creating a broader spectrum of prototypes. However, potential for optimizations will be discussed.
