
\chapter{Method 2: Tri-dexel}
\label{ch:tri_dexel}

The second discussed method to extract a triangulated surface from the VML's data model is based on a tri-dexel representation, \cf section \ref{sec:surface_representations}.
As observed with the previously shown method in chapter \ref{ch:direct_intersection}, reconstructing a surface directly form the many intersecting triangles stored in the VML's grid is computationally expensive, highly numerically unstable and prone to errors.
A more robust approach is desirable, which is able to always successfully reconstruct a surface with good quality.
This reconstruction should succeed independently of the complexity of the maintained geometry.
As a trade-off for this robustness, the approach may sacrifice surface exactness and filigree features.
Dexel-based representations fit this purpose nicely.
They provide a good abstraction of a machined workpiece with rich semantics.
The used grid resolution supplies an easy to configure level of detail and steering parameter between representation quality and memory/CPU demands.
Creating dexel-based representations from the VML's data model is achieved using an adaption of the already implemented, well-working and robust raycasting subsystem used for visualization, \cf section \ref{sec:raycasting}.
To achieve a good portrayal independently of the workpiece's orientation, three axis-aligned dexel images will be generated, thus creating a tri-dexel representation.
For converting such a tri-dexel model into a final triangle mesh, various algorithms are found in literature.
An excellent example is Ren \etal's "Feature Conservation and Conversion of Tri-dexel Volumetric Models to Polyhedral Surface Models for Product Prototyping" \cite{tridexel_reconstruction}.
Their approach form the idea and foundation of the implementation presented in this chapter.


\section{Concept}
\label{sec:tri_dexel_concept}

Firstly, a tri-dexel representation of the VML's data model has to be obtained.
Dexel images, in general, are created by sampling the workpiece's surface along parallel lines.
This sampling process is already implemented in the raycasting subsystem as part of the visualization.
However, when sampling dexels, a ray must not stop at the first surface intersection, but continue through the whole data model and collect all intersections along its path.
At each intersection, the intersection depth, \ie distance from the ray's origin, and the surface normal of the intersected triangle is recorded as a dexel node.
From the dexel's origin and a node's depth the intersection point can be calculated.
The raycast itself is performed with axis-parallel rays starting at equidistant origins from three sides of the VML's data model, thus creating three dexel images.
Combining these dexel images creates a uniform regular grid, the tri-dexel grid.
Figure \ref{fig:cylinder_head_dexel} shows the cylinder head scene with a low-resolution dexel image and the final reconstruction.

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_stock_and_svs}
		\caption{Stock and SVs}
		\label{fig:cylinder_head_stock_sv}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_vml}
		\caption{VML}
		\label{fig:cylinder_head_classified}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_dexel_image}
		\caption{Tri-dexel image}
		\label{fig:cylinder_head_dexel_image}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_dexel_image_center}
		\caption{Tri-dexel image center}
		\label{fig:cylinder_head_dexel_image_center}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_dexel_image_fins}
		\caption{Tri-dexel image fins}
		\label{fig:cylinder_head_dexel_image_fins}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cylinder_head_reconstructed}
		\caption{Result}
		\label{fig:cylinder_head_reconstructed}
	\end{subfigure}
	\caption{
		Tri-dexel based surface reconstruction from the VML's data model of a cylinder head.
		Figure \ref{fig:cylinder_head_stock_sv} shows the stock and a few swept volumes creating the fins and drillings.
		Figure \ref{fig:cylinder_head_classified} shows the classification result after these solids have been mapped into the VML's regular grid.
		The removed triangles are clearly visible, especially at the swept volumes.
		By using a raycast of axis parallel rays along all three coordinate system axes a tri-dexel representation is created as shown in figure \ref{fig:cylinder_head_dexel_image}.
		The resolution of the grid spawning the rays is 30 along the longest dimension.
		Figure \ref{fig:cylinder_head_dexel_image_center} and \ref{fig:cylinder_head_dexel_image_fins} show details of the tri-dexel image.
		The former views the drilling at the center from above and the latter views the cylinder head's fins from the center.
		Finally, the reconstructed surface is shown in figure \ref{fig:cylinder_head_reconstructed}.
		Note the imperfections at the fin's edges and bases.
	}
	\label{fig:cylinder_head_dexel}
\end{figure}

Secondly, the tri-dexel representation is converted into a triangle mesh.
This procedure is mostly based on the paper already mentioned during the introduction \cite{tridexel_reconstruction}.
Each intersection point of three orthogonal dexels from the tri-dexel grid forms a grid point.
If a grid point lies within a dexel segment on any of these dexels, it is said to be occupied, \ie lies within the workpiece's volume.
8 grid points and their 12 connecting edges along with their dexel segments are grouped into cells of the grid.
Each grid cell is then processed independently.
Figure \ref{fig:tri_dexel_cell} shows the structure of a tri-dexel cell.
%
\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{images/tri_dexel_cell}
	\caption{
		A cell of a tri-dexel grid \cite{tridexel_reconstruction}.
		Occupied grid points are drawn in red, dexel nodes in green, dexel segments in blue.
		Each grid point is referenced using a number between 0 and 7 and has a list of neighboring grid points in counter-clockwise order, \cf left table.
	}
	\label{fig:tri_dexel_cell}
\end{figure}
%
Before a cell can be triangulated, a few consistency checks and corrections are applied to the cell.
This process is called regularization and ensures a successful triangulation into a water-tight mesh.
After ensuring the consistency of a cell, it can be triangulated.
For this purpose, a depth-first search process is iteratively started at non-occupied grid points of the cell to discover boundary loops.
Basically, the found loops can be triangulated right away to obtain a water tight mesh.
However, the quality of the triangulation can be further enhanced by taking normal information at the dexel nodes into account.
This is especially necessary to reconstruct features of the model.
This optional feature reconstruction pass is run on the loops found in the previous step and may create additional vertices.

\section{Implementation}
\label{sec:tri_dexel_implementation}

In order to run the tri-dexel surface reconstruction, the user must supply a resolution as parameter.
This resolution determines the size of the raycasted dexel images as well as the resulting tri-dexel grid.
For esthetic reasons, the specified resolution is only used for the longest dimension of the workpiece.
The resolution along the other dimensions is usually smaller in order to make the cells more cubic, although the implementation does not require cubic cells.


In addition to the types already specified by the VML, \cf figure \ref{fig:vml_datamodel}, the tri-dexel reconstruction algorithm requires a few more types.
Most of these type definitions and also the algorithms themselves are vastly simplified when compared with the underlying source code.
Especially parallelism, asynchrony, memory efficient handling of data structures and numeric stability enhancements have been intentionally left out in the discussed pseudo code.
The additional types needed for the tri-dexel implementation are shown in the class diagram in figure \ref{fig:tri_dexel_datamodel}.
%
\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/tri_dexel_datamodel}
	\caption{
		Simplified UML class diagram of the types needed for the tri-dexel reconstruction algorithm in addition to the types used by the VML, \cf figure \ref{fig:vml_datamodel}.
	}
	\label{fig:tri_dexel_datamodel}
\end{figure}
%
The most central data structure is the \var{TriDexelGrid} class.
It represents a tri-dexel representation of the complete VML workpiece which is already prepared for subsequent regularization and triangulation.
In addition to the tri-dexel grid's resolution \var{res} and bounding box \var{aabb}, the \var{TriDexelGrid} class further contains the occupancy information for each grid point in \var{occupancy}, \ie whether a grid point is spanned by a dexel or not, as well as the actual dexel segments between the grid points, stored in \var{edges}.
The \var{cells} method separates all this information into distinct and independent cells.
Each cell is an instance of the \var{Cell} class and contains the same information as the tri-dexel grid, but locally for a single cell.
A cell stores it's bounding box \var{box}, the point occupancy of each of the cell's corners in \var{occupancy}, the corners' coordinates in \var{realPoints} and the 12 edges of the cell, stored in \var{edges}.
Each edge of the cell is an instance of \var{Edge} and contains all spanning dexel segments, clamped to the interval between the edge's incident grid points.
Furthermore, a method \var{isBoundary} is provided to check if the cell is a boundary cell, \ie contains occupied and non-occupied grid points and therefore contains a part of the workpiece's surface.
The \var{TriDexelGrid} is constructed from the \var{TriDexelImage} class, which, fundamentally, contains the same information as the tri-dexel grid.
The difference is substantially clearer from the workflow's point of view.
Whereas the \var{TriDexelGrid} is already prepared for further processing, the \var{TriDexelImage} class only contains the raw result as created by raycasting the VML's data model from three orthogonal directions.
This data only consists of the resolution \var{res} used for raycasting as well as three dexel images \var{images} along the three coordinate system axes.
A \var{DexelImage} describes the result of a single raycast along the axis specified in \var{axis0}, where 0 denotes the x-, 1 the y- and 2 the z-axis.
The members \var{axis1Res} and \var{axis2Res} store the resolution of the dexel image along the two cyclically following axes after \var{axis0}.
For example, if \var{axis0} is 1, the y-axis, then \var{axis1Res} and \var{axis2Res} hold the resolutions along the axes 2 and 0, the z- and x-axis.
Finally, \var{dexels} contains all the dexels of the image.
Each \var{Dexel} instance is then essentially a list of nodes, stored in \var{nodes}.
The number of stored nodes after raycasting is always a multiple of two.
As dexel nodes are typically processed in pairs, as dexel segments, a convenience method \var{segments} is provided which groups adjacent nodes into instances of \var{DexelSegment}.
A \var{DexelSegment} contains these two nodes as \var{start} and \var{end} node.
Finally, the \var{Node} class holds the depth of the node along its dexel, \ie the distance of the node from the plane where the dexels originate, \cf figure \ref{fig:dexel_image}, as well as the normal vector of this surface entry/exit.
Unrelated to the tri-dexel types are two additional classes, which are used in some algorithms during the reconstruction.
The \var{Ray} class represents a ray starting at the vertex \var{origin} and traveling into the direction stored by \var{direction}.
The \var{EdgeVertex} class holds data to represent a vertex on an edge of a tri-dexel cell.
It contains grid point indices for the two points incident to this vertex's edge, a position and the surface normal of the vertex.

Based on the discussed tri-dexel types, the basic reconstruction algorithm is shown in algorithm \ref{alg:tri_dexel}.
%
\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Function{TriDexel}{$\var{grid}, \var{resolution}$}
			\State $\var{box} = \var{Extends}(\var{grid}.\var{aabb}.\var{lower} - \epsilon, \var{grid}.\var{aabb}.\var{upper} + \epsilon)$
			\State $\var{res} = \Call{UniformResolution}{\var{box}, \var{resolution}}$
			\State $\var{img} = \var{TriDexelImage}(\var{res})$
			\State $\Call{AxisParallelRaycast}{\var{grid}, \var{box}, \var{res},\hfill\break
				\hspace*{\dimexpr\algorithmicindent*2}(\var{axis}, \var{x}, \var{y}, \var{v}, \var{n}) \rightarrow \var{img}.\var{images}_{\var{axis}}.\var{dexels}_{\var{x}, \var{y}}.\var{nodes}.\var{add}(\var{Node}(\var{v}_{\var{axis}}, \var{n}))}$
			\State $\var{dgrid} = \Call{CreateTriDexelGrid}{\var{img}, \var{box}}$
			\State $\var{triangles} \gets \varnothing$
			\ForAll{$\var{c} \in \var{dgrid}.\var{cells}()$}
				\State $\Call{RegularizeCell}{\var{c}}$
				\State $\var{triangles} \gets \var{triangles} \cup \Call{TriangulateCell}{\var{c}}$
			\EndFor
			\State \Return $\var{triangles}$
		\EndFunction
	\end{algorithmic}
	\caption{
		Abstract workflow of the surface reconstruction using a tri-dexel approach.
	}
	\label{alg:tri_dexel}
\end{algorithm}
%
At the beginning, a slightly enlarged bounding box is calculated for the size of the tri-dexel grid and raycast.
In this way, edge cases with a surface exactly at the grid's border are avoided.
The \textproc{UniformResolution} function takes the user-specified resolution and the tri-dexel grid's bounding box and calculates three resolutions, one for each axis.
The longest one is equal to the specified resolution and the other two are calculated in such a way that the resulting cells of the tri-dexel grid are as cubic as possible.
This resolution is used to preallocate space for the tri-dexel image which is then filled in the subsequent raycasting process.
The remaining part of the algorithm closely follows the concept discussed in the previous section\ref{sec:tri_dexel_concept}.
The subsequent sections discuss the functions and procedures of the algorithm in the order they are used.


\subsection{Raycast}
\label{sec:tri_dexel_raycast}

The raycast is the prime algorithm for converting the VML's data model into a tri-dexel representation.
The raycast is performed with parallel, axis-aligned and equidistant rays.
All rays start at the intersection points of a uniform 2-dimensional grid placed on one side of the data model's slightly enlarged bounding box and end at the opposite side, \cf figure \ref{fig:dexel_image}.
Three of these raycasts along the three axes of the coordinate system result in three dexel images.
As the raycasting code is kept separated from the tri-dexel data structures, a function is passed to the raycasting code which is invoked each time a ray has found a surface intersection.
Therefore, the same code can be used to create other data structures as well. %TODO: ref point cloud creation

The entry routine and ray creation code of the raycasting algorithm is shown in algorithm \ref{alg:tri_dexel_raycast}.
%
\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Procedure{Raycast}{$\var{grid}, \var{box}, \var{res}, \var{hitFunc}$}
			\For{$\var{axis0} \gets 0 \To 2$}
				\State $\var{axis1} \gets (\var{axis0} + 1) \bmod 3$
				\State $\var{axis2} \gets (\var{axis0} + 2) \bmod 3$
				\State $\var{xCount} \gets \var{res}_{\var{axis1}}$
				\State $\var{yCount} \gets \var{res}_{\var{axis2}}$
				\State $\Delta \var{x} \gets (\var{box}.\var{upper}_{\var{axis1}} - \var{box}.\var{lower}_{\var{axis1}}) \div (\var{xCount} - 1)$
				\State $\Delta \var{y} \gets (\var{box}.\var{upper}_{\var{axis2}} - \var{box}.\var{lower}_{\var{axis2}}) \div (\var{yCount} - 1)$
				\For{$\var{y} \gets 0 \To \var{yCount} - 1$}
					\For{$\var{x} \gets 0 \To \var{xCount} - 1$}
						\State $ray = \Call{CreateRay}{\var{box}, \var{axis0}, \var{axis1}, \var{axis2}, \var{\Delta x}, \var{\Delta y}, \var{x}, \var{y}}$
						\State $\Call{CastRay}{\var{grid}, \var{axis0}, \var{axis1}, \var{axis2}, \var{ray},\hfill\break
							\hspace*{\dimexpr\algorithmicindent*5}(\var{v}, \var{n}) \rightarrow \var{hitFunc}(\var{axis0}, \var{x}, \var{y}, \var{v}, \var{n})}$
					\EndFor
				\EndFor
			\EndFor
		\EndProcedure
		\\
		\Function{CreateRay}{$\var{box}, \var{axis0}, \var{axis1}, \var{axis2}, \var{\Delta x}, \var{\Delta y}, \var{x}, \var{y}, \var{xCount}, \var{yCount}$}
			\State $\var{origin} \gets \var{box}.\var{lower}$
			\State $\var{origin}_{axis1} \gets \var{origin}_{\var{axis1}} + \var{x} * \var{\Delta x}$
			\State $\var{origin}_{axis2} \gets \var{origin}_{\var{axis2}} + \var{y} * \var{\Delta y}$
			\State $\var{direction} = \var{Vertex}(0, 0, 0)$
			\State $\var{direction}_{\var{axis0}} \gets 1$
			\State \Return $\var{Ray}(\var{origin}, \var{direction})$
		\EndFunction
		\\
		\Procedure{CastRay}{$\var{grid}, \var{axis0}, \var{axis1}, \var{axis2}, \var{ray}, \var{hitFunc}$}
			\State $\var{traverser} \gets \var{AxisAlignedTraverser}(\var{grid}, \var{ray}, \var{axis0}, \var{axis1}, \var{axis2})$
			\While{$\neg \var{traverser}.\var{reachedEnd}()$}
				\State $\var{cell} \gets \var{traverser}.\var{nextCell}()$
				\State $\Call{IntersectCell}{\var{cell}, \var{ray}, \var{axis0}, \var{axis1}, \var{axis2}, \var{hitFunc}}$
			\EndWhile
		\EndProcedure
	\end{algorithmic}
	\caption{
		Basic algorithm for performing a parallel raycast along all three coordinate system axes on the VML's data model.
	}
	\label{alg:tri_dexel_raycast}
\end{algorithm}
%
The outmost procedure \textproc{Raycast} takes four arguments: the VML's regular grid data structure, the slightly enlarged bounding box of the raycasted area, the resolution of the raycasted \enquote{image} as well as a function, which is called on every surface hit.
The algorithm starts of by iterating over the three coordinate system's axes.
The index of each axis is stored in the variable \var{axis0}, where 0 denotes the x-, 1 the y- and 2 the z-axis.
\var{axis0} is also called primary axis and is accompanied by \var{axis1} and \var{axis2} which hold the other two, secondary axes, in cyclic order.
Depending on the choice of primary and secondary axes, the resolution of the 2-dimensional grid spawning the rays is determined and assigned to \var{xCount} and \var{yCount}, for the horizontal and vertical resolution.
Afterwards, the distance between two incident rays along both secondary axes is computed.
Therefore, along both secondary axes, the size of the bounding box is computed and divided by the resolution minus one.
The result is assigned to the variables \var{\Delta x} and \var{\Delta y}.
Now the algorithm starts creating and casting all rays along their primary axis.
Two nested loops iterate over all points of the 2-dimensional grid spawning rays.
For each grid point at $\var{x}, \var{y}$ a ray is created using the \textproc{CreateRay} function.
Subsequently, the ray is cast into the VML's regular grid by invoking \textproc{CastRay}, passing a closure which is invoked each time a hit is recorded.

The \textproc{CreateRay} function's objective is to create an instance of \var{Ray} storing the ray's origin and direction.
The origin is calculated by starting from the bounding box's \var{lower} corner.
Along the primary axis, this value is already correct.
On the secondary axes, the origin, currently at the origin for ray $0, 0$, must be moved according to the ray's \var{x} and \var{y} coordinate.
In order to do so, \var{x} and \var{y} are multiplied by the distances between incident rays, \var{\Delta x} and \var{\Delta y}, and added to the origin's secondary axes.
%
Computing the ray's direction is simpler, as it is axis aligned.
Therefore, the direction is a unit vector along the primary axis, created by setting the corresponding component of a zeroed vector to one.
%
Finally, \var{origin} and \var{direction} are aggregated into an instance of \var{Ray} and returned.

After rays have been created, they are cast into the VML's regular grid data structure to find surface intersections using the \textproc{CastRay} procedure.
Traversing a ray through a regular grid is usually done using the 3D-DDA algorithm \cite{3DDDA}, \cf figure \ref{fig:traverser}.
However, as the rays are axis parallel, traversal essentially boils down to mapping the ray's origin to the appropriate grid cell and incrementing the 3-dimensional cell index along the primary axis until the other end of the grid is reached.
This logic is hidden behind the \var{AxisAlignedTraverser} class and is no further elaborated.
%
The ray is then intersected with each cell pulled from the traverser using the \textproc{IntersectCell} algorithm.
Fundamentally, the implementation is based on the inside counting scheme of the visualization code explained in figure \ref{fig:raycast}.
The important difference is that the raycast for visualization may terminate after the first intersection found.
Furthermore, minor inconsistencies are tolerable and may result in a few pixel errors on the final image.
However, when creating dexels, a consistent number of surface entries and exits as well as numerically correct ordering of the intersections is substantial.
Consequently, such an intersection routine must employ a great deal of numeric precautions and extra checks to deliver a correct result, even sacrificing intersections for the sake of consistency.
This procedure forms the heart of the raycasting algorithm.
As it is quite comprehensive and highly tailored to the VML's internal data structures, the detailed pseudocode of the \textproc{IntersectCell} routine is omitted from the thesis.


\subsection{Tri-dexel image and grid generation}
\label{sec:tri_dexel_dexel_image_generation}

Based on the generic, axis parallel raycasting routine, a tri-dexel image is created in the base algorithm \ref{alg:tri_dexel}.
Before the raycast is lauched, an instance of \var{TriDexelImage} is created, preallocating enough space to hold 3 dexel images, each holding a 2-dimensional grid of empty dexels.
When calling \textproc{AxisParallelRaycast} procedure, an anonymous function is passed which is invoked on every surface hit detected during raycasting.
This function receives the primary axis \var{axis}, \ie the axis along the rays where traversed, \var{x} and \var{y} coordinate on the 2-dimensional dexel grid as well as the intersection point \var{v} with the normal of the hit triangle \var{n}.
With this information, the tri-dexel image stored in \var{img} is populated.
Once raycasting has completed, the tri-dexel grid is generated from the tri-dexel image.
This conversion is more a reinterpretation and preparation of the information contained within the tri-dexel image.
Whereas the image contains the raw raycasting result, the tri-dexel grid already stores grid point occupancy information and cuts all dexels at cell borders.
This preparation eases the follow-up processing of individual cells.

Converting the tri-dexel image into a tri-dexel grid is done by the \textproc{CreateTriDexelGrid} function, which is shown in algorithm \ref{alg:tri_dexel_grid_generation}.
%
\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Function{CreateTriDexelGrid}{$\var{triImage}, \var{box}$}
			\State $\var{res} = \var{triImage}.\var{res}$
			\State $\var{grid} = \var{TriDexelGrid}(\var{res}, \var{box})$ \Comment{$\forall x, y, z : grid.occupancy_{x, y, z} = \False$}
			\For{$\var{axis0} \gets 0 \To 2$}
				\State $\var{axis1} \gets (\var{axis0} + 1) \bmod 3$
				\State $\var{axis2} \gets (\var{axis0} + 2) \bmod 3$
				\State $\var{image} \gets \var{triImage.images}_{\var{axis0}}$
				\For{$\var{axis1Val} \gets 0 \To \var{res}_{\var{axis1}} - 1$}
					\For{$\var{axis2Val} \gets 0 \To \var{res}_{\var{axis2}} - 1$}
						\State $\var{dexel} \gets image.\var{dexels}_{\var{axis1Val}, \var{axis2Val}}$
						\ForAll{$\var{seg} \in \var{dexel}.\var{segments}()$}
							\LineComment{Compute affected grid point range}
							\State $\var{start} \gets \Call{DepthToGrid}{\var{seg}.\var{start}.\var{depth}, \var{axis0}, \var{res}, \var{box}}$
							\State $\var{end} \gets \Call{DepthToGrid}{\var{seg}.\var{end}.\var{depth}, \var{axis0}, \var{res}, \var{box}}$
							\For{$\var{axis0Val} \gets \var{start} \To \var{end}$}
								\State $\var{gridFrom}$
								\State $\var{gridFrom}_{\var{axis0}} \gets \var{axis0Val}$
								\State $\var{gridFrom}_{\var{axis1}} \gets \var{axis1Val}$
								\State $\var{gridFrom}_{\var{axis2}} \gets \var{axis2Val}$
								\State $\var{gridTo} \gets \var{gridFrom}$
								\State $\var{gridTo}_{axis0} \gets \var{gridTo}_{\var{axis0}} + 1$
								\State $\var{depthFrom} = \Call{GridToDepth}{\var{gridFrom}_{\var{axis0}}, \var{axis0}, \var{res}, \var{box}}$
								\State $\var{depthTo}   = \Call{GridToDepth}{\var{gridTo}_{\var{axis0}}, \var{axis0}, \var{res}, \var{box}}$
								\LineComment{Point occupancy}
								\If{$\var{seg}.\var{start}.\var{depth} \leq \var{depthFrom} \leq \var{seg}.\var{end}.\var{depth}$}
									\State $\var{grid}.\var{occupancy}_{\var{gridFrom}} \gets \True$
								\EndIf
								\If{$\var{seg}.\var{start}.\var{depth} \leq \var{depthTo} \leq \var{seg}.\var{end}.\var{depth}$}
									\State $\var{grid}.\var{occupancy}_{\var{gridTo}} \gets \True$
								\EndIf
								\LineComment{Copy segment and clamp to cell border}
								\State $\var{s} \gets \var{seg}$
								\If{$\var{s}.\var{start}.\var{depth} < \var{depthFrom}$}
									\State $\var{s}.\var{start}.\var{depth} \gets \var{depthFrom}$
								\EndIf
								\If{$\var{s}.\var{end}.\var{depth} > \var{depthTo}$}
									\State $\var{s}.\var{end}.\var{depth} \gets \var{depthTo}$
								\EndIf
								\State $\var{grid}.\var{edges}_{\var{axis0}, \var{gridFrom}}.\var{segments}.\var{add}(\var{s})$
							\EndFor
						\EndFor
					\EndFor
				\EndFor
			\EndFor
		\EndFunction
		\\
		\Function{DepthToGrid}{\var{depth}, \var{axis}, \var{res}, \var{box}}
			\State \Return $\floor{(\var{depth} - \var{box}.\var{lower}_{\var{axis}}) \div (\var{box}.\var{upper}_{\var{axis}} - \var{box}.\var{lower}_{\var{axis}}) \cdot (\var{res}_{\var{axis}} - 1)}$
		\EndFunction
		\\
		\Function{GridToDepth}{\var{gridCoord}, \var{axis}, \var{res}, \var{box}}
			\State \Return $\var{gridCoord} \div (\var{res}_{\var{axis}} - 1) \cdot (\var{box}.\var{upper}_{\var{axis}} - \var{box}.\var{lower}_{\var{axis}}) + \var{box}.\var{lower}_{\var{axis}}$
		\EndFunction
	\end{algorithmic}
	\caption{
		Creating a tri-dexel grid from the raycasted dexel images.
	}
	\label{alg:tri_dexel_grid_generation}
\end{algorithm}
%
The algorithm starts by constructing an instance of the $TriDexelGrid$ class.
During this construction, \ie the constructor, the occupancy of each grid point is set to \False.
Furthermore, space to hold all edges of the tri-dexel grid is allocated.
Accessing grid edges, \ie subscripting the member \var{edges}, is done by supplying the axis to which the edge is parallel as well as a three dimensional position.
Afterwards, the algorithm iterates over all three axes of the coordinate system and therefore over the three dexel images of the tri-dexel image.
For each dexel image, further loops are necessary to iterate over all dexels of the image and for each dexel over its segments.
For each segment, the affected range of grid points is computed.
Two coordinates of these points are already known, which are the same as the coordinates of the dexel in its image.
The third, missing coordinates are the ones spanned by the dexel segment.
To compute these coordinates, the dexel segment's start and end depth are mapped to grid point coordinates.
Each call to \textproc{DepthToGrid} yields the lower grid point coordinate along the specified axis for a given depth on this axis.
This value is also equivalent to the index of the edge along \var{axis} on which a dexel node with the given depth would lie.
The computed range, \var{start} to \var{end}, in conjunction with \var{axis1Val} and \var{axis2Val}, now gives all indices of the affected grid points and edges.
The innermost loop finally iterates over all edges of the tri-dexel grid spanned by the current dexel segment \var{seg}.
The variables \var{gridFrom} and \var{gridTo} are the indices of the grid points incident to the current edge, which's index is also \var{gridFrom}.
For both grid points of the current edge a depth value along the current axis is calculated.
Two conditionals then compare these depth values against the start and end depth of the current dexel segment.
If the depth of any grid point is between a dexel segment's start and end depth, \ie the segment spans the grid point, it is marked as occupied by setting the corresponding element of the grid's \var{occupancy} member.
After this point occupancy check, the segment must also be added to the current edge, incident to both grid points.
As the cells of the tri-dexel grid are later processed independently and to make some calculations easier, the dexel-segments are further clamped to the cell's bounds, \ie constrained to the cell's grid point's depth values.
Therefore, a copy of the current segment is made and the start and end depth set to the respective grid point's depth values in case they are outside.
Finally, the clamped segment is added to the current edge.
%
After the call to \textproc{CreateTriDexelGrid} returned, the tri-dexel image is no longer needed as the semantically equivalent information is stored in the newly created tri-dexel grid.
The main algorithm, algorithm \ref{alg:tri_dexel}, may release resources held for the \var{img} variable now.
The newly created tri-dexel grid \var{dgrid} is now used iterate over all cells and process them further.
The call to $\var{dgrid}.\var{cells}()$, for each cell, collects all data from the tri-dexel grid belonging to a single cell into an instance of \var{Cell}.
The created cells contain deep copies of the grid's data, as the cell's edges are conceptually shared with neighboring cells, but will be modified in subsequent parts of the algorithm.
This poses no problem in a single threaded context, but would lead to data races when multiple cells are processed concurrently, \cf section \ref{sec:tri_dexel_parallelization}.


\subsection{Regularization}
\label{sec:tri_dexel_regularization}

During the conversion of the VML's data model into a tri-dexel representation errors may occur.
Dexels segments for example might not be of accurate length because of numerics in the triangle intersection routine or corrections applied by the raycaster when sorting and counting through the intersected structures to identify surface hits.
Such defects are especially critical at the intersection points of dexels from multiple dexel images, the grid points.
Furthermore, the number of different configurations a single tri-dexel cell may have is huge, as each edge may contain an arbitrary number of dexel segments, rendering the creation of an appropriate triangulation algorithm almost impossible.
It is thus beneficial to reduce the number of cases by dropping some information in favor of regularity.

The process of repairing defects and reducing complexity of a tri-dexel cell is called regularization.
This method is documented well in the tri-dexel paper foundational to this chapter \cite{tridexel_reconstruction}.
Regularizing a tri-dexel cell is done by iterating over all edges and applying a set of rules.
These rules are illustrated in figure \ref{fig:tri_dexel_regularization} and are as follows:

\begin{figure}[h]
	%\renewcommand{\thesubfigure}{\arabic{subfigure}}
	\centering
	\begin{subfigure}[t]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/tri_dexel_regularization_1}
		\caption{Two occupied points.}
		\label{fig:tri_dexel_regularization_1}
	\end{subfigure}
	\begin{subfigure}[t]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/tri_dexel_regularization_2}
		\caption{Two non-occuupied points}
		\label{fig:tri_dexel_regularization_2}
	\end{subfigure}
	\begin{subfigure}[t]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/tri_dexel_regularization_3}
		\caption{One occupied point with no segment}
		\label{fig:tri_dexel_regularization_3}
	\end{subfigure}
	\begin{subfigure}[t]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/tri_dexel_regularization_4}
		\caption{Deletion of non-spanning segments}
		\label{fig:tri_dexel_regularization_4}
	\end{subfigure}
	\caption{
		The four regularization rules which are applied to each tri-dexel cell before it is triangulated.
		Image adapted from \cite{tridexel_reconstruction}.
	}
	\label{fig:tri_dexel_regularization}
\end{figure}

\begin{enumerate}
	\item If two adjacent grid points are marked as occupied, the incident edge must contain exactly one dexel segment with start and end depth exactly at the corresponding positions of the grid points.
	Figure \ref{fig:tri_dexel_regularization_1} shows the extension of the leftmost segment to touch the occupied grid point in the upper left.

	\item If two adjacent grid points are not marked as occupied, the incident edge must not contain any dexel segments.
	Figure \ref{fig:tri_dexel_regularization_2} shows the removal of the leftmost segment from an edge beween two non-occupied grid points.

	\item If any edge, which is only incident to exactly one occupied grid point, does not contain a dexel segment touching this point, a short segment is added.
	Figure \ref{fig:tri_dexel_regularization_3} shows the creation of two small dexel segments at both lower grid points as the left and right edge do not contain any segments.

	\item If any segment does not touch any of the two incident grid points, it is removed.
	Figure \ref{fig:tri_dexel_regularization_4} shows the removal of segments on the left and right edge which do not touch any grid point.
\end{enumerate}

These rules are applied to each cell of the tri-dexel grid constructed so far.
The implementation of these regularization rules, \ie the \textproc{RegularizeCell} routine, is detailed in algorithm \ref{alg:tri_dexel_regularization}.
%
\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Function{RegularizeCell}{$\var{cell}$}
			\For{$ i \gets 0 \To 11 $}
				\State $segs \gets cell.edge_i.segments$ \Comment{reference only}
				\State $(src, dst) \gets edgeIndexToCorners_i$
				\State $srcPoint \gets cell.realPoints_{src}$
				\State $dstPoint \gets cell.realPoints_{dst}$
				\State $srcOcc \gets cell.occupancy_{src}$
				\State $dstOcc \gets cell.occupancy_{dst}$
				\State $axis \gets edgeToAxis_{src, dst}$
				
				\LineComment{Rule 1}
				\If{$srcOcc \wedge dstOcc$}
					\State $n \gets Vertex()$ \Comment{Invalid normal}
					\State $segs = \{ Segment(Node(srcPoint_{axis}, n), Node(dstPoint_{axis}, n)) \}$
				\EndIf
				
				\LineComment{Rule 2}
				\If{$\neg srcOcc \wedge \neg dstOcc$}
					\State $segs \gets \varnothing$
				\EndIf
				
				\LineComment{Rule 3}
				\State $n = Vertex(0, 0, 0)$
				\State $n_{axis} = 1$
				\If{$srcOcc \wedge \neg dstOcc$}
					\If{$|segs| = 0 \vee segs_0.start.depth \neq srcPoint_{axis}$}
						\State $segs.add(Segment(Node(srcPoint_{axis}, -n), Node(srcPoint_{axis} + \rho, n)))$
					\EndIf
				\EndIf
				\If{$\neg srcOcc \wedge dstOcc$}
					\If{$|segs| = 0 \vee segs_{|segs| - 1}.end.depth \neq dstPoint_{axis}$}
						\State $segs.add(Segment(Node(dstPoint_{axis} - \rho, -n), Node(dstPoint_{axis}, n)))$
					\EndIf
				\EndIf
				
				\LineComment{Rule 4}
				\ForAll{$s \in segs$}
					\If{$s.start.depth \neq srcPoint_{axis} \wedge s.end.depth \neq dstPoint_{axis}$}
						\State $segs.remove(s)$
					\EndIf
				\EndFor
			\EndFor
		\EndFunction
	\end{algorithmic}
	\caption{
		Regularizing a cell of the tri-dexel grid by applying the four rules specified in figure \ref{fig:tri_dexel_regularization} \cite{tridexel_reconstruction}.
	}
	\label{alg:tri_dexel_regularization}
\end{algorithm}
%
Regularizing a cell essentially boils down to processing all 12 edges of the cell, indexed from 0 to 11.
For each edge a bit of meta information is retrieved using some lookup tables.
These tables are shown in figure \ref{fig:tri_dexel_tables} and relate cell corners, edges and axes.
%
\begin{figure}
	\begin{subfigure}[t]{0.24\textwidth}
		\begin{align*}
		\text{neighborIds:} \\
		0: (1, 4, 2) \\
		1: (0, 3, 5) \\
		2: (0, 6, 3) \\
		3: (1, 2, 7) \\
		4: (0, 5, 6) \\
		5: (1, 7, 4) \\
		6: (2, 4, 7) \\
		7: (3, 6, 5)
		\end{align*}
	\end{subfigure}
	\begin{subfigure}[t]{0.24\textwidth}
		\begin{align*}
		\text{edgeToPointIds:} \\
		 0: (0, 1) \\
		 1: (2, 3) \\
		 2: (4, 5) \\
		 3: (6, 7) \\
		 4: (0, 2) \\
		 5: (1, 3) \\
		 6: (4, 6) \\
		 7: (5, 7) \\
		 8: (0, 4) \\
		 9: (1, 5) \\
		10: (2, 6) \\
		11: (3, 7)
		\end{align*}
	\end{subfigure}
	\begin{subfigure}[t]{0.24\textwidth}
		\begin{align*}
		\text{pointsToEdgeId:} \\
		(0, 1), (1, 0):  0 \\
		(2, 3), (3, 2):  1 \\
		(4, 5), (5, 4):  2 \\
		(6, 7), (7, 6):  3 \\
		(0, 2), (2, 0):  4 \\
		(1, 3), (3, 1):  5 \\
		(4, 6), (6, 4):  6 \\
		(5, 7), (7, 5):  7 \\
		(0, 4), (4, 0):  8 \\
		(1, 5), (5, 1):  9 \\
		(2, 6), (6, 2): 10 \\
		(3, 7), (7, 3): 11
		\end{align*}
	\end{subfigure}
	\begin{subfigure}[t]{0.24\textwidth}
		\begin{align*}
		\text{edgeToAxis:} \\
		(0, 1), (1, 0): 0 \\
		(2, 3), (3, 2): 0 \\
		(4, 5), (5, 4): 0 \\
		(6, 7), (7, 6): 0 \\
		(0, 2), (2, 0): 1 \\
		(1, 3), (3, 1): 1 \\
		(4, 6), (6, 4): 1 \\
		(5, 7), (7, 5): 1 \\
		(0, 4), (4, 0): 2 \\
		(1, 5), (5, 1): 2 \\
		(2, 6), (6, 2): 2 \\
		(3, 7), (7, 3): 2
		\end{align*}
	\end{subfigure}
	\caption{
		Various helper tables used by regularization and triangulation algorithms.
	}
	\label{fig:tri_dexel_tables}
\end{figure}
%
For a given edge index, the indices of the incident grid points are retrieved, called \var{src} and \var{dst}, where \var{src} is always the grid point with the lower depth value.
In addition to the index, the coordinate and occupancy is also retrieved in \var{srcPoint}, \var{dstPoint}, \var{srcOcc} and \var{dstOcc}.
Finally, the axis parallel to the edge is looked up and stored in \var{axis}.
Afterwards, the algorithm starts to apply the regularization rules.
%
For the first rule, the occupancy of both grid points is checked.
If both of them are occupied, the existing segments on the edge are replaced by a new set with a new segment spanning from the source to the destination grid point.
As both incident grid points are occupied, the edge cannot contain a surface intersection.
Therefore, the normal on the dexel nodes can be safely ignored.
%
The second rule states that if both grid points are not occupied, the incident edge must be empty.
Thus, in this case, all segments are simply removed.
%
Rule three is applied if only one grid point is marked as occupied.
If segments are present on the current edge, the algorithm tests whether the first or last segment touches the grid point which is marked as occupied.
If the source point is marked, the first segment's start must touch it, \ie must have equal depth than the grid point.
In case the destination point is marked, the last segment's end must touch it.
If there are no segments on the edge or the present segments do not touch their appropriate points, a new dexel segment is added.
The new segment starts at the occupied grid point and has a small length of $\rho$.
This length can be chosen arbitrarily, but as it's purpose is to correct a numeric issue, a tiny value is sufficient.
Regarding the normal, the surface intersection represented by the newly added segment might be used by a later triangulation.
However, the true normal is stored on the numerically too short segment in the appropriate neighboring cell, which is hard to retrieve as the tri-dexel grid's cells are isolated to allow independent processing.
Hence, an artificial normal is added in the direction of the edge's axis.
%
The last rule, rule 4, finally checks all segments if they touch at least one grid point.
If any segment does not satisfy this condition, the segment is removed.
%
After all 4 rules have been applied to all 12 edges of the cell, the cell is regularized and fulfills a few properties:
\begin{itemize}
	\item Between two occupied grid points, there is always a full segment.
	\item Between two non-occupied grid points, there is never a segment.
	\item Between two differently marked grid points, there is exactly one segment with one node not equal to the depth of the occupied grid point.
\end{itemize}
These properties now allow for a subsequent triangulation.


\subsection{Triangulation}
\label{sec:tri_dexel_triangulation}

After regularization, a cell of the tri-dexel grid is ready for triangulation.
The process of creating triangles from a cell is done in three steps where the second one is optional.
Firstly, set of boundary loops is created from the grid points and dexel nodes between them.
Secondly, from the loop, vertex and normal information, optional feature points are created.
Thirdly, the boundary loops with optional feature information are triangulated.

For the initial boundary loop discovery, a depth-first search process is iteratively started at non-occupied grid points of the cell.
The search traverses the cell's edges and backtracks each time an occupied grid point and therefore a grid edge containing a dexel node is found.
Traversed grid points are marked as visited and cause future searches to backtrack immediately.
The list of visited grid edges containing dexel nodes, per search, in the order they where visited, form a boundary loop.
A cell might contain multiple boundary loops, which are found in multiple searches when starting at different, non-occupied grid points.

Figure \ref{fig:tri_dexel_triangulation} illustrates this depth-search process by two examples.
%
\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/tri_dexel_triangulation}
	\caption{
		Triangulating a tri-dexel cell by finding boundary loops using depth-first search along the cube, starting at non-occupied nodes \cite{tridexel_reconstruction}.
	}
	\label{fig:tri_dexel_triangulation}
\end{figure}
%
In the upper example, a single boundary loop is discovered.
The search starts at grid point 1.
At each grid point, a list of neighbors has to be retrieved.
These neighbor ids make up a small table which is listed in figure \ref{fig:tri_dexel_tables} and beside the two examples in figure \ref{fig:tri_dexel_triangulation}.
The neighbors of a grid point are further traversed in counter-clockwise order, starting at the next neighbor after the one from which the current grid point has been reached.
At the first grid point of the search, the neighbor to start with may be chosen freely, and is usually the first one of the neighbor ids table.
At grid point 1, the neighbors 0, 3 and 5 are traversed.
Neighbors 0 and 3 reach an occupied grid point and therefore cause the search to backtrack, storing the dexel nodes A and B on the edges to 0 and 3.
As the neighbor 5 is non-occupied, the search continues with its neighbors, 1, 7, and 4.
Grid point 1 is omitted, as it has already been visited.
Grid point 7 is further traversed and backtracks at point 3 and 6, resulting in the dexel nodes C and D.
Grid point 4 produces the nodes E and F.
Afterwards, the search backtracks until the starting point is reached and terminates.
In visited order, the dexel nodes A to F form a boundary loop.
Further searches started at other grid points immediately return as all non-occupied nodes have already been visited by the search started at point 1.
%
In the lower example of figure \ref{fig:tri_dexel_triangulation}, the depth-first search discovers multiple boundary loops.

Triangulating a cell with occupancy information at its corners and vertices on it's edges into triangles is a problem which is also discussed in voxel-based surface reconstruction techniques, such as the marching cubes variants.
In fact, a tri-dexel cell with 8 boolean occupancy values at the corners represents one of $2^8 = 256$ cases.
Therefore, the boundary loop configuration and also the triangulation could also be precomputed for each case and stored in a lookup table.
This strategy is typically found in the original and many derived marching cubes implementations \cite{marching_cubes}.
As a matter of fact, the tables used by these marching cubes implementations, actually any table, could be used to triangulate tri-dexel cells.

The depth-first search approach, however, does have an issue with 4 of the 256 configurations.
If only two grid points are occupied and lie on diagonally opposing corners of the cell, they form two boundary loops which are both discoverable by a single depth-first search.
This causes a problem, as the search discovers 6 vertices, which do not make up a single but two loops.
Therefore, these cases have to be handled differently.
A simple solution is to just start the depth-first search at the occupied grid points, resulting in two loops, and reverse the vertex order.

Algorithm \ref{alg:tri_dexel_triangulation} shows the basic triangulation of a tri-dexel cell without any feature reconstruction.
%
\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Function{TriangulateCell}{$\var{cell}$}
			%\State $loops$
			\If{$\neg \Call{IsProblematicCase}{cell}$}
				\State $loops \gets \Call{FindLoops}{\var{cell}, \False}$
			\Else
				\State $loops \gets \Call{ReverseLoops}{\Call{FindLoops}{\var{cell}, \True}}$
			\EndIf
			\State $triangles \gets \varnothing$
			\For{$loop \in loops$}
				\State $triangles \gets triangles \cup \Call{TriangulateLoopSimple}{loop}$
			\EndFor
			\State \Return $triangles$
		\EndFunction
		\\
		\Function{FindLoops}{$\var{cell}, occupied$}
			\State $visited \gets (\False, \False, \False, \False, \False, \False, \False, \False)$
			\State $loops \gets \varnothing$
			\For{$start \gets 0 \To 7$}
				\State $loop \gets array()$
				\State $\Call{DepthFirstSearch}{occupied, start, -1, cell, visited, loop}$
				\If{$|loop| > 0$}
					\State $loops.add(loop)$
				\EndIf
			\EndFor
			\State \Return $loops$
		\EndFunction
		\\
		\Function{DepthFirstSearch}{$occupied, cur, last, cell, visited, loop$}
			\If{$cell.occupancy_{cur} = occupied \wedge \neg visited_{cur}$}
				\State $visited_{cur} \gets \True$
				\State $neighbors \gets \Call{RotateToStartAfter}{neighborIds_{cur}, last}$
				\For{$n \in neighbors$}
					\If{$cell.occupancy_{n} \neq occupied$}
						\State $axis \gets edgeToAxis_{cur, n}$
						\State $seg \gets cell.edges_{pointsToEdgeId_{cur, n}}.segments_0$
						\State $curReal \gets cell.realPoints_{cur}$
						\State $nReal \gets cell.realPoints_{n}$
						\If{$seg.start.depth = curReal_{axis} \vee seg.start.depth = nReal_{axis}$}
							\State $node \gets seg.end$
						\Else
							\State $node \gets seg.start$
						\EndIf
						\State $v \gets curReal$
						\State $v_{axis} \gets node.depth$
						\State $loop.add(EdgeVertex(cur, n, v, node.normal))$
					\Else
						\State $\Call{DepthFirstSearch}{occupied, n, cur, cell, visited, loop}$
					\EndIf
				\EndFor
			\EndIf
		\EndFunction
		\\
		\Function{TriangulateLoopSimple}{$loop$}
			\State $vertices \gets \Call{Map}{loop, v \rightarrow v.position}$
			\State $center \gets \Call{Sum}{vertices} \div |vertices|$
			\State \Return $\Call{TriangulateLoop}{vertices, center}$
		\EndFunction
	\end{algorithmic}
	\caption{
		Basic triangulating routine for a tri-dexel cell.
		No refinement or feature reconstruction is done.
	}
	\label{alg:tri_dexel_triangulation}
\end{algorithm}
%
The \textproc{TriangulateCell} function begins by checking if the cell is one of the 4 problematic cases, \ie cases with two, diagonally opposing occupied grid points.
In non problematic cases, the \textproc{FindLoops} function is called, starting at non-occupied vertices.
In problematic cases, the loop search routine is started at occupied vertices and the resulting loops reversed.
After all loops have been identified, they are sent to the \textproc{TriangulateLoopSimple} function which generates triangles from the loop.
The union of all triangulated loops is returned as triangulation result of the given tri-dexel cell.
%
The \textproc{FindLoops} algorithm is the entry into the depth-first search based traversal of the cell's edges as shown in figure \ref{fig:tri_dexel_triangulation}.
It starts by initializing an array with eight boolean values set to false.
These values keep track of the already visited vertices.
For each of the 8 possible start grid points an empty array \var{loop} is created which is passed recursively through the following depth-first search.
It collects information about the encountered dexel nodes, in the order they are visited, to form a boundary loop.
The call to \textproc{DepthFirstSearch} then starts traversing the cell's edges starting at the grid point \var{start}.
After the call has returned, a conditional checks if loop vertices have been found and adds the loop in this case.
After a search has been launched from each start point, the set of collected loops is returned.
%
The recursive \textproc{DepthFirstSearch} algorithm is the heart of the boundary loop discovery.
Initially, it checks if the current grid point is equal to \var{occupied} and has not been visited yet.
The parameter \var{occupied} is usually false for the default case, \ie the search traverses on non-occupied points, and only true in problematic cases.
If both conditions are met, the point is marked as visited and the list of neighbor points is fetched.
This list is rotated to start at the index right after the one the search came from.
This rotation ensures, that each neighbors are visited in counter-clockwise order as seen from the incoming edge.
In case of the first call to \textproc{DepthFirstSearch}, there is no last visited point, \var{last} is $-1$, and the neighbor list is not rotated.
For each neighboring grid point, it is checked for inequality to \var{occupied}.
If this is true, the \var{cur} and \var{n} have different occupancy and the edge between them contains a vertex of the surface.
This vertex is now constructed from the corresponding dexel node together with some meta data.
Using the \var{edgeToAxis} table of figure \ref{fig:tri_dexel_tables}, the axis parallel to the current edge is obtained.
Using \var{pointsToEdgeId}, the segment on the corresponding cell's edge is also retrieved.
Furthermore, the coordinates of the current and neighboring grid point are stored in local variables.
The \var{node} variable is then set to the dexel node which does not touch one of the grid points.
The vertex on the current edge is then constructed starting with the coordinate of the current grid point \var{curReal}.
Choosing the neighboring grid point's coordinate is also valid, as both coordinates only differ at the component at \var{axis}.
This component of the new vertex is then set to the selected node's depth.
Finally, an instance of \var{EdgeVertex} is added to the boundary loop, containing both grid point's ids, the newly calculated vertex and the corresponding surface normal as obtained from the dexel node.
Afterwards, the function returns and the search backtracks.
In case the current neighbor's occupancy is equal to \var{occupied}, \ie no vertex on the current edge, the depth-first search is recursively continued with the current point index passed as last and the neighbor index passed as current.

Finally, the \textproc{TriangulateLoopSimple} function just maps each \var{EdgeVertex} of the passed loop to its position, creating a pure list of 3D vertices.
The sum of these vertices, divided by their count, yields their center of mass, stored in \var{center}.
This value is used to ultimately create a triangle fan from the loop's vertices with around \var{center}.


\subsection{Refinement and feature reconstruction}
\label{sec:tri_dexel_refinement}

This optional feature reconstruction pass is run on the loops found in the previous step.
Using the normals of each pair of adjacent dexel nodes of the loop, an additional intermediate/feature point may be created.
Using the normals of multiple nodes, a further apex vertex may be created per loop.
Finally, these enhanced loops are also triangulated.

\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/tri_dexel_refinement}
	\caption{
		Triangulating a tri-dexel cell's boundary loops with additional feature information \cite{tridexel_reconstruction}.
		The left image shows the creation of two intermediate vertices.
		The right image shows the creation of three intermediate vertices and an apex vertex.
	}
	\label{fig:tri_dexel_refinement}
\end{figure}


\subsection{Subslicing *experimential*}
\label{sec:tri_dexel_subslicing}



\subsection{Parallelization}
\label{sec:tri_dexel_parallelization}

raycast, parallel cell processing


\section{Results}
\label{sec:tri_dexel_results}


