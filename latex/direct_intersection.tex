
\chapter{Method 1: Direct intersection}
\label{ch:direct_intersection}

The first presented method to extract a triangulated surface from the VML's data model is by directly processing the stored triangles inside the VML's regular grid.
This approach is the most naive, computationally intensive, but, in theory, most accurate.
It is conceptually equivalent to directly intersecting the mesh of the stock with each swept volume mesh.
Boolean operations on triangle meshes are already available in most CAD kernels.
However, these kernels usually require the meshes to be closed.
Due to the triangle elimination strategy using cell classification, \cf section \ref{sec:classification}, the meshes stored in the regular grid are no longer closed.
Thus, regular CAD kernels cannot be used to intersect the meshes maintained by the VML and a custom mesh intersection algorithm has been developed.


\section{Concept}
\label{sec:direct_intersection_concept}

Every time a swept volume is added to the VML, a unique id is generated and assigned to each of the swept volume's triangles before they are mapped to the cells of the regular grid.
As the stock is internally treated as a swept volume, by inverting the surface normals, all stock triangles are also assigned a unique id.
These ids allow to separate the triangles contained in the regular grid into the previous swept volumes, referred to as structures.
The separated structures are processed in pairs.
Each pair is united into a new structure.
The union of the two structure meshes is calculated by intersecting each triangle of one mesh with each triangle of the other mesh.
If two triangles intersect, the intersection line is recorded for both triangles.
After intersection, each triangle with intersection lines is split along these lines, retriangulated and replaced by the triangles resulting from the retriangulation.
All previous intersection lines are now edges of new triangles.
Each triangle of one structure is then tested against the other structure, whether the triangle is inside or outside the other structure, \eg by casting a ray from the triangle to the other structure.
As all triangles intersecting the opposite structure have been split, this property should be unambiguously determinable for each triangle.
By removing all triangles inside the opposite structure, the remaining triangles form a new surface which corresponds to the union of both structures.
This new structure is then again pairwise united with other structures until only one structure is left, \ie all structures are reduced to one.
This final structure is the reconstructed surface of the VML's data model.
Figure \ref{fig:cube2} demonstrates this workflow by the example of intersecting a cube with a cuboid.

\begin{figure}
	\centering
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_stock_sv}
		\caption{Stock and SV}
		\label{fig:cube2_stock_sv}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_classified}
		\caption{VML}
		\label{fig:cube2_classified}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_constraints}
		\caption{Intersections}
		\label{fig:cube2_constraints}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_retriangulated}
		\caption{Retriangulation}
		\label{fig:cube2_retriangulated}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_eliminated}
		\caption{Inside test}
		\label{fig:cube2_eliminated}
	\end{subfigure}
	\begin{subfigure}[t]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{images/cube2_result}
		\caption{Result}
		\label{fig:cube2_result}
	\end{subfigure}
	\caption{
		Surface reconstruction from the VML's data model by the example of intersecting a cube and a cuboid.
		Figure \ref{fig:cube2_stock_sv} shows the cubic stock, in the lower left, and a tilted cuboid as swept volume, in the upper right.
		Figure \ref{fig:cube2_classified} shows the classification result when these two solids are mapped into the VML's regular grid.
		Most of the swept volume's triangles have been removed.
		When intersecting both structures, \ie swept volume and stock triangles, all intersection lines per triangle are recorded.
		Regarding the swept volume's triangles, these are shown in figure \ref{fig:cube2_constraints}.
		The triangles are then retriangulated with respect to those intersections as shown in figure \ref{fig:cube2_retriangulated}.
		Afterwards, each triangle is tested against the other structure, whether they are inside and can be removed.
		The result of testing the retriangulated swept volume's triangles against the stock is shown in figure \ref{fig:cube2_eliminated}.
		The retriangulation and inside test is analogously done for the stock structure.
		Finally, the reconstructed surface is the union of the remaining triangles, figure \ref{fig:cube2_result}.
	}
	\label{fig:cube2}
\end{figure}


\section{Implementation}
\label{sec:direct_intersection_implementation}

Due to the regular grid's classification, \cf section \ref{sec:classification}, triangles might have been removed and, consequently, the structures put together from the regular grid's cells may no longer be closed meshes.
As it turns out, the test whether a triangle is inside another structure may fail if the tested structure is not a closed mesh, a common case.
An example of such an issue is shown in figure \ref{fig:inside_test_error}.
%
\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{inside_test_error}
	\caption{
		Testing if a triangle of one structure is inside another structure using a ray.
		Due to triangle elimination, the ray can miss removed structures, \eg when traversing outside cells, causing the inside test to fail, \cf left ray.
		As structures are guaranteed to be closed within a cell, this test is only valid within a cell, \cf right ray.
	}
	\label{fig:inside_test_error}
\end{figure}
%
A triangle is tested against a structure by using a ray.
This ray is shot from an arbitrary point on the triangle, which does not lie on an edge, \eg the triangle's centroid, to an arbitrary point on a triangle of the other structure.
If the ray does not intersect the other structure on its way, a comparison of the ray's direction with the normal of the targeted triangle determines whether the ray's origin, \ie the centroid of the tested triangle, is inside the other structure or not.
However, as classification might eliminate triangles, the ray could potentially intersect triangles of the structure which have been removed, \cf left ray in figure \ref{fig:inside_test_error}.
The regular grid only guarantees closed meshes within a cell.
To circumvent this issue, the inside test for a triangle must be conducted within a cell.

In general, intersecting each triangle of a structure against each other triangle of another structure is an expensive undertaking.
The cost of this operation is $\mathcal{O}(n^2)$, assuming both structures have $n$ triangles.
Intersecting the structures at the level of each cell greatly reduces the value of $n$.
Unfortunately, many triangles usually span the bounding box of a cell and are duplicated in each encompassed cell.
To avoid duplicates or overlapping triangles when combining results from neighboring cells, all triangles of a cell have to be clipped against the cell's bounding box.
This step can be done before or after intersecting the structures of a cell, but always before starting to eliminate triangles against the opposite structure.

An abstracted algorithm of this reconstruction approach is shown in algorithm \ref{alg:direct_intersection}.
The following sections discuss details of this algorithms and follow the order of subroutines/functions which are not yet defined.
The only exception is the \textproc{SeparateStructures} routine, which only groups the incoming triangles by their structure id.
It returns a list of structures, where each structure is a set of triangles.

\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Function{DirectIntersection}{$\var{grid}$}
			\State $\var{result} \gets \varnothing$
			\ForAll{$\var{c} \in \var{grid.cells}$}
				\If{$\var{c.classification} = \var{surface}$}
					\State $\var{structures} \gets \Call{SeparateStructures}{\var{c.triangles}}$
					\If{$\left\vert{\var{structures}}\right\vert = 1$}
						\State $\var{result} \gets \var{result} \cup \Call{ClipStructure}{\var{structures.pop()}}$
					\ElsIf{$\left\vert{\var{structures}}\right\vert > 1$}
						\State $\var{acc} \gets \var{structures.pop()}$
						\While{$\left\vert{\var{structures}}\right\vert > 0$}
							\State $\var{s} \gets \var{structures.pop()}$
							\State $\var{acc} \gets \Call{UnionStructure}{\var{acc}, \var{s}, \var{c.aabb}}$
						\EndWhile
						\State $\var{result} \gets \var{result} \cup \var{acc}$
					\EndIf
				\EndIf
			\EndFor
			\State \Return $\var{result}$
		\EndFunction
		\\
		\Function{UnionStructure}{$\var{s_1}, \var{s_2}, \var{cellBox}$}
			\ForAll{$\var{s} \in \{\var{s_1}, \var{s_2\}}$}
				\State $s \gets \Call{ClipStructure}{\var{s}, \var{cellBox}}$
			\EndFor
			\State $\var{lines} \gets \var{map()}$ \Comment{maps each triangle to a set of lines}
			\ForAll{$(\var{t_1}, \var{t_2}) \in \var{s_1} \times \var{s_2}$}
				\State $\var{l} \gets \Call{IntersectTriangles}{\var{t_1}, \var{t_2}}$
				\If{$\var{l}$} \Comment{no intersection line may be found}
					\State $\var{lines}(\var{t_1}) \gets \var{lines}(\var{t_1}) \cup \{\var{l}\}$
					\State $\var{lines}(\var{t_2}) \gets \var{lines}(\var{t_2}) \cup \{\var{l}\}$
				\EndIf
			\EndFor
			\ForAll{$\var{s} \in \{\var{s_1}, \var{s_2}\}$}
				\State $\var{s'} \gets \varnothing$
				\ForAll{$\var{t} \in \var{s}$}
					\State $\var{s'} \gets \var{s'} \cup \Call{SplitTriangle}{\var{t}, \var{lines}(\var{t})}$
				\EndFor
				\State $\var{s} \gets \var{s'}$
			\EndFor
			\State $\var{result} \gets \varnothing$
			\ForAll{$(\var{s}, \var{s'}) \in \{(\var{s_1}, \var{s_2}), (\var{s_2}, \var{s_1})\}$}
				\ForAll{$\var{t} \in \var{s}$}
					\If{\Not $\Call{IsTriangleInsideStructure}{\var{t}, \var{s'}}$}
						\State $\var{result} \gets \var{result} \cup \{\var{t}\}$
					\EndIf
				\EndFor
			\EndFor
			\State \Return $\var{result}$
		\EndFunction
	\end{algorithmic}
	\caption{
		Abstract workflow of the surface extraction using direct intersection of the VML's stored structures.
	}
	\label{alg:direct_intersection}
\end{algorithm}


\subsection{Clipping}
\label{sec:clipping}

Clipping triangles against the bounding box of a cell is necessary to avoid duplicated or invalid surfaces.
In cases where triangles span multiple cells, the VML duplicates each triangle into each cell it encompasses.
During intersection, only a triangle's intersections with structures of the current cell are recorded, although the triangle might be intersected by additional geometry in neighboring cells.
Therefore, after splitting, parts of the triangle which are outside the current cell are never split, might pass the inside test as a whole and remain as additional triangles outside the actual surface or remain colinear with surface triangles from neighboring cells.
To circumvent these issues, all triangles of a cell have to be clipped either before or after intersecting the two structures in \textproc{UnionStructure}.

Algorithms for clipping triangles against a bounding box are found in literature.
....


Sutherland–Hodgman algorithm for clipping polygons \cite{polygon_clipping}


\subsection{Triangle intersection}
\label{sec:triangle_intersection}
	
Möller paper
	
\subsection{Triangle splitting}
\label{sec:triangle_splitting}

CDT
list available libraries
reference crytec paper

\subsection{Triangle inside structure test}
\label{sec:triangle_inside_test}



\subsection{Numeric improvements}
\label{sec:numeric_improvements}

mostly makeRobustChains()


\subsection{Parallelization}
\label{sec:parallelization}


per cell is easy.
at cell level, structure union is a tree-shaped reduction
at union level, triangle-triangle intersections may run fully parallel for each triangle pair, elimination may run fully parallel




\section{Results}
\label{sec:direct_intersection_results}

Why it does not work on larger meshes?
Run time complexity
Numerical robustness

