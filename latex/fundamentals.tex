\chapter{Fundamentals} % and theoretical background (BASICS)
\label{ch:fundamentals}

%TODO: uniform names for "piece of geometry", "solid", "(geometric) model",  ...

\section{Surface representations}
\label{sec:surface_representations}

CAD and CAM software use several different representations for final and intermediate geometric parts like cutter geometries, the manufactured workpiece or the current machining state.
Tukora provides a comprehensive overview with sketches and descriptions of the most commonly used representations in the area of virtual machining on which the following section is based on \cite{virtual_machining_review}. 

\begin{description}
	\item[Vector clipping] \hfill \\
	Vector clipping is mainly used in CAE to verify the correctness of a generated (C)NC program before it is run on an actual milling machine and has been first described by Chappel \cite{vector_clipping} in 1983.
	The method requires the geometries of the final workpiece as well as the stock (\ie the original piece of material it has been cut out of).
	Initially, points on the final workpiece are calculated together with surface normals (\ie a point cloud) where the normals are not necessary of unit length but long enough to reach the surface of the stock.
	To simulate the manufacturing process, the cutter is moved over this point cloud and the vectors attached to the points are clipped by the moving cutter (\cf figure \ref{fig:vector_clipping}).
	Tukora compares this method to a lawn mower, which cuts the grass (\ie the normal vectors) towards the ground (\ie the final workpiece).
	After cutting has completed, the lengths of the remaining vectors indicate the local error of the (C)NC program.
	Vectors with positive lengths mark areas where too less material has removed and vice versa.
	The vector lengths are finally used to color the final workpiece where the color indicates the severity of the machining error. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\textwidth]{images/vector_clipping}
		\caption{
			The vector clipping method as described by Chappel \cite{vector_clipping}.
			Image by Tukora \cite{virtual_machining_review}.
		}
		\label{fig:vector_clipping}
	\end{figure}
	 
	 
	\item[Z-maps and depth images] \hfill \\
	Describing geometries using z-maps has been proposed by Anderson \cite{zmap} in 1978.
	According to Tukora it is furthermore the most widespread representation used in 3-axis material removal simulations.
	Z-maps approximate a piece of geometry by sampling its height at each crossing of a regular 2-dimensional grid.
	This grid is usually placed perpendicular to the cutting direction at one side of the stock (\eg the bottom).
	The volume of the z-mapped geometry can be seen as the union of right square prisms where a prism is placed on each crossing of the grid with the height sampled at the crossing.
	Figure \ref{fig:zmap} shows such a prism approximation of a cuboid stock with a ball-end cutter removing material.
	As a z-map is a 2-dimensional scalar field with values at discrete regular positions, it can therefore be seen as an image, commonly referred to as depth image.
	
	Material is removed by creating a depth image for each cutter movement (\aka sweep) with the same position and orientation as the depth image of the workpiece.
	The sweep's depth image describes the removed material during the sweep.
	It is combined with the depth image of the workpiece by updating all depth values to be the minimum value of the workpiece's and sweep's depth image.

	Processing depth images can be greatly accelerated using GPUs as they contain special hardware for dealing with per-pixel depth information (\ie depth buffer or z-buffer).
	
	However, z-map representations have a fundamental drawback.
	As each depth value can only store the distance to a single surface points, z-maps cannot represent geometries with a back-face or covered surfaces.
	
	\begin{figure}[h]
		\centering
		\begin{subfigure}[b]{0.4\textwidth}
			\includegraphics[width=\textwidth]{images/zmap}
			\caption{Prism representation of a z-map}
			\label{fig:zmap}
		\end{subfigure}
		\begin{subfigure}[b]{0.4\textwidth}
			\includegraphics[width=\textwidth]{images/depth_image}
			\caption{depth image}
			\label{fig:depth_image}
		\end{subfigure}
		\caption{
			Representation of a cuboid stock with material removed using a ball-end cutter.
			The geometry described by the z-map is represented using right square prisms in the left image.
			The z-map can be stored in a grayscale image as shown on the right.
			Images by Tukora \cite{virtual_machining_review}.
		}
	\end{figure}
	
	
	\item[Dexel images] \hfill \\
	Dexel based representations have been proposed by Hook to circumvent the shortcomings of depth images \cite{dexel}.
	Instead of a scalar value per pixel of a regular 2-dimensional grid (z-maps) a complex data element is stored, called a dexel (abbreviated from depth element).
	A dexel is created by tracing a ray starting at a grid point perpendicular to the grid's plane through the workpiece and collecting all surface intersections.
	Each dexel stores a sorted list of these intersections, where an intersection is also called a dexel node.
	A node basically contains the depth value of the intersection and can contain further informations such as a surface normal or a color value.
	Pairs of dexel nodes where the first node has been an entry and the second an exit are called segments and always lie inside the workpiece.
	Figure \ref{fig:dexel_image} shows a dexel representation of a half sphere with a smaller, concentric half sphere drilled out.
	
	Material removal is done in a similar fashion as with with z-maps.
	A dexel image is created for a sweep and then combined with the dexel image of the current workpiece.
	Instead of updating to the minimum value as done with z-maps, a 1-dimensional boolean subtraction of all sweep dexels from the workpiece dexels is performed.
	
	Compared with image based representations like z-maps and depth images, dexel based approaches are able to represent overlapping surfaces and workpieces with a front- and a back-face.
	Nevertheless, the sampling resolution from the surface's perspective is dependent on the orientation of the surface towards the dexel grid.
	The more parallel the surface is to the grid, the smaller becomes the distance between two neighboring entry/exit points on the surface.
	In case the surface is perpendicular to the grid, the dexels lie parallel to the surface and do not capture any intersections.
		
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{images/dexels}
		\caption{
			Dexel image for a half sphere with a smaller, concentric half sphere drilled out.
			Image adapted from Tukora \cite{virtual_machining_review}.
		}
		\label{fig:dexel_image}
	\end{figure}
		
		
	\item[Multi-dexel images] \hfill \\
	To increase the accuracy of dexel based models, especially in regions of the surface where the surface normals are parallel to the dexels, multiple dexel images can be used.
	This idea has been described by Benouamer \etal in 1997 to provide a good representation that can combine BRep and CSG models \cite{tridexel_intersection}.
	Although multiple dexel images can be created from any orientations, it is common to create three dexel images along the three axes of a Cartesian coordinate system.
	Therefore, the 2-dimensional dexel grids lie in the three planes defined by pairs of the coordinate system's axes (xy, yz, zx plane).
	This case of multi-dexel image is also referred to as triple- or tri-dexel image.
	Figure \ref{fig:tri_dexel_image} shows a triple-dexel representation of an octant of a centered unit sphere.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{images/tridexels}
		\caption{
			Tri-dexel images of an octant of a centered unit sphere.
			The left, blue image shows dexels along the x-axis, the centered, red image along the z-axis and the right, green image along the y-axis.
			Images by Tukora \cite{virtual_machining_review}.
		}
		\label{fig:tri_dexel_image}
	\end{figure}


	\item[Constructive Solid Geometry (CSG)] \hfill \\
	CSG is a technique widely spread in solid modeling.
	It has its origins in 1978 where Gossard and Tsuchiya tried to use set theory to verify material removal in NC processes \cite{csg}.
	CSG describes a piece of geometry by its construction process from a set of simple primitives, making it therefore an interesting approach in procedural modeling.
	Although primitives are typically basic shapes such as cubes, spheres or cylinders, they can in theory be any kind of complex shape.
	Pairs of primitives can be combined using boolean set operations such as union, intersection or difference.
	The result of such an operation is a new geometric model, which can be again combined with other models or further primitives.
	These combinations can be visualized as a tree as shown in figure \ref{fig:csg_tree}.
	
	In virtual machining, material removal can be described simply as subtracting a new solid (a geometric model)  which corresponds to the volume swept by the cutter during a single movement (\aka swept volume).
	Additive manufacturing (e.g. 3D printing) is also easily representable by adding a new solid.
	
	CSG trees can also be rendered directly using OpenGL or DirectX by making use of the GPU's depth and stencil buffers.
	Well known algorithm's in this area include Goldfeather's algorithm \cite{goldfeather} and Nigel's Sequenced Convex Subtraction (SCS) algorithm \cite{scs}.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{images/csg_tree}
		\caption{
			A solid object modeled using CSG.
			The final shape of the object at the top is the result of combining the primitives at the bottom using boolean operations.
			Image from Wikimedia Commons \cite{csg_tree}.
		}
		\label{fig:csg_tree}
	\end{figure}
	
	\item[Spacial decomposition] \hfill \\
	The volume covered by a solid can also be represented by listing regions in 3-dimensional space which are occupied by the volume.
	This representation is also commonly known as spacial occupancy enumeration.
	To enumerate occupied regions, one must first decompose space into smaller regions.
	This can be done in a uniform or hierarchical manner.
	
	Uniform spacial decomposition (USD) divides space into equally sized cells.
	An example would be a regular grid with cubic cells.
	This special case is known as voxel model, where a voxel (abbreviated from volume element) is a single cell of the regular grid.
	Figure \ref{fig:spacial_decomposition}(b) shows a voxel model of a simple solid.
	
	USDs are simple to create and implement as they only require a three dimensional grid which stores for every cell whether it is occupied or not.
	Boolean operations are also easily solved, as two uniform grids can be combined on a per cell basis similar to z-maps.
	However, USDs are highly memory demanding to achieve a sufficient resolution to accurately represent a solid.
	Furthermore, a high resolution may only be needed in certain regions of the solid (\ie features).
	
	Hierarchical spacial decomposition (HSD) overcomes some shortcomings of USDs.
	HSDs partition space in an adaptive way and increase their resolution only where detail is necessary.
	Therefore, HSDs usually require less memory at the cost of increased complexity.
	Figure \ref{fig:spacial_decomposition}(c) shows an example of a solid represented by a hierarchically decomposed space.
	
	A common representative of HSDs are octrees.
	An octree on its highest level is a cube which is then recursively subdivided into eight half-sized cubes (\aka octants).
	This subdivision is only done, where a finer decomposition of space is necessary.
	Further examples of hierarchical decompositions are Binary Space Partitioning (BSP) and Bounding Volume Hierarchies (BVH).
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{images/spacial_decomposition}
		\caption{
			The solid on the left side can be described using spacial decomposition in either a uniform manner (middle image) or a hierarchical manner (right image).
			Image by Tukora \cite{virtual_machining_review}. 
		}
		\label{fig:spacial_decomposition}
	\end{figure}
	

	\item[Boundary representation (BRep)] \hfill \\
	Boundary representations, according to Tukora, are the most wide-spread representations used in modern CAD systems.
	As the term suggests, BReps describe a solid by specifying its boundary surface.
	This surface typically consists of faces (bounded surfaces), edges between those faces (bounded curves) and vertices (\ie points in 3-dimensional space) as well as their topology.
	Faces can be specified using a variety of mathematical models from complex splines (BSpline, NURB) to simple polygons like triangles.
	Figure \ref{fig:brep} shows an example of a BRep which represents a machining part using triangles as faces.
	%
	In the field of virtual machining, the faces of BReps are typically polygons which are connected by straight edges (\ie polyhedrons).
	The most common case are triangle meshes, although quad meshes are also popular in CAD.
	%
	Boolean operations like subtraction are hard to perform on arbitrary BReps.
	When considering only triangulated surfaces, the undertaking becomes doable, but still remains calculatively expensive and usually suffers from numerics.
	Boolean operations on triangulated BReps are typically available in modern CAD kernels.
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=\textwidth]{images/brep}
		\caption{
			A boundary representation describes a machining part be specifying its boundary surface. A popular surface representation is a set of connected triangles. 
			Image by Tukora \cite{virtual_machining_review}. 
		}
		\label{fig:brep}
	\end{figure}
	
	\item[Functional representation (FRep)] \hfill \\
	From a more mathematical point of view, surfaces can also be represented using real-valued functions.
	Pasko \etal give a good overview on this subject in the context of modeling and computer graphics \cite{frep}.
	\Eg a sphere is defined analytically as the infinite set of points with the same distance (radius) to a distinct center point.
	By defining a function for the distance of a point to the center, subtracting the radius and equating it with zero, we can construct a predicate that holds true for all points on the sphere's surface.
	More generalized, an object can be specified by classifying all spatial points $P$ using a continuous, real-valued function $f$. For each point $p \in P$
	\begin{align}
		f(p) &> 0 \quad \text{if $p$ is inside the object,}               \notag \\
		f(p) &= 0 \quad \text{if $p$ is on the surface of the object and} \notag \\
		f(p) &< 0 \quad \text{if $p$ is outside the object.}              \notag
	\end{align}
	
	Functional representations shine in exactness, expressiveness and memory requirements.
	Additionally, some classes of problems are easier to solve on analytical models, \eg intersection tests.
	Furthermore, boolean operations and manipulations like bending and twisting are easier to formulate on mathematical entities then on the other data structures discussed in this section.
	
	Many primitives used in CSG are easily typically described using FReps.
	Several CAD kernels also use FReps internally to retain precision until the final result is exported where it is typically converted into a \eg a BRep.
	
\end{description}


\section{Triangulation terms}
\label{sec:definitions}

\begin{description}
	\item[Triangulation/Tesselation]
	
	\item[Mesh]
	
	\item[Manifold]
	
	\item[Oriented]
	
	\item[Closed/water-tight]
	
	\item[Boundary]
	
	\item[Voronoi]
	
	\item[Delaunay]
	A triangulation is called Delaunay when the circumcircle of each triangle does not contain a vertex of another triangle.
	Delaunay triangulations produce very regular and visually appealing triangle meshes.
	
	\item[Gabriel 2-Simplex]
	
	\item[Chord error]
	
\end{description}


\section{Surface reconstruction}
\label{sec:surface_reconstruction}

where is surface reconstruction used?
